---
title: 'Análisis y reporte del chrome stealer - ChromeUpdater.exe'
date: 2023-08-21 15:00:00 +0200
categories: [Malware Analysis,Stealer]
tags: [Malware,Stealer,Golang]
image:
  path: /assets/img/commons/chrome-updater/0Chrome.png
  width: 600
  height: 300
---


Analizar los propios **malwares personalizados** es vital para **saber detectarlos** posteriormente. 
Por ello, he creado un **malware stealer de credenciales en Golang**. 

Toda la infraestructura está creada y ejecutada de forma *local*, por lo que no sale fuera de la red.

**OffensiveGolang** es uno de los uno de los repositorios que me ha facilitado la programación como el desarrollo del exfiltrado de datos, para crearlo. Muy recomendable.

<a href="https://github.com/MrTuxx/OffensiveGolang/" target="_blank">https://github.com/MrTuxx/OffensiveGolang/tree/main</a>

<br/>

Para **ofuscar el malware** he utilizado esta herramienta que es la cual luego un simple comando *strings* no puede encontrar mucho y  el **análisis es más complicado y duradero**.<br/>
Con garble utilicé también una *semilla de aleatoriedad de ofuscación*.

<a href="https://github.com/burrowers/garble" target="_blank">https://github.com/burrowers/garble</a>

<br/>

Para la **recolección** de todos estos **archivos exfiltrados**, los recibí en un **Kali Linux** donde tenía levantado un **Flask app.**

El malware **no es detectado** por el **antivirus** windows defender ya que es algo desconocido y no puede basarse en los signatures y la detección estática es bypasseada.

A continuación, voy a escribir un informe donde podemos ver el funcionamiento del malware:

---

## Resumen ejecutivo

ChromeUpdater es un stealer en busca de exfiltrar artefactos de Google Chrome como por ejemplo: contraseñas y cookies. El malware encripta los archivos en AES y los exfiltra a una IP privada.

El malware está programado en Golang para Windows.

**Los primeros indicadores son:**

- Al iniciarlo solo se muestra en la barra de tareas
- Esta aplicación solo dura milisegundos y se cierra
- Cuando se cierra, se borra así mismo


## Resumen técnico de alto nivel

Lo primero que hace el stealer es una busqueda de los siguientes archivos del path de ‘/AppData/Local/Google/Chrome/User Data’:

- Cookies
- History
- Web Data
- Bookmarks
- Login Data
- Local State

Después de leer los archivos, los encripta con una clave “01234567890abcdef” AES.

Hace una conexión con `httx://10.10.10.6:8080/endpoint`  y envia los archivos a través de un método POST en forma de JSON (clave valor) y una vez finalizado, procede a borrarse a si mismo con un `cmd.exe /C del`.

### Composición de malware

```bash
chromeUpdater.exe
SHA256 Hash:
FF6AFE9A7FF8D8C451CCBD3C5A0F473025D36074173A027B39FEECE45E78DA63
MD5 Hash:
0194AF976819E40CC63AD795D1F5CACE
```

### Análisis estático

Este malware no ofrece ningún tipo de **“Time Date Stamp”** en PEView

![PEView]({{ 'assets/img/commons/chrome-updater/1Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

En las propiedades del ejecutable **no encontramos** alguna **descripción** ni **versión** ni **nombre** ni tampoco alguna **firma digital**.

![Propiedades]({{ 'assets/img/commons/chrome-updater/2Chrome.png' | relative_url }}){: width="550" height="450" .center-image }

Como vemos ahora y veremos después, el lenguaje es **Golang** y está escrito para **Windows**.

![Lenguaje]({{ 'assets/img/commons/chrome-updater/3Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Llevando el archivo a PEStudio, **confirmamos** que no hay **ningún compiler-stamp ni firma**, ni otro tipo de información 

![PEStudio]({{ 'assets/img/commons/chrome-updater/4Chrome.png' | relative_url }}){: width="850" height="850" .center-image }

Algunas de las API a las que llama son para tratar hilos y es por eso que parecen del tipo Process Injection pero no hay más con “flag” interesantes

![API]({{ 'assets/img/commons/chrome-updater/5Chrome.png' | relative_url }}){: width="750" height="750" .center-image }

Extrayendo los **strings** a un documento vemos que está escrito en Golang por la terminación **".go"** en muchos de los strings que hay y podemos ver el comportamiento en base a ello como **syscall_windows.go**, que hará llamadas al sistema que permiten a las aplicaciones interactuar con funciones de bajo nivel.

![Strings]({{ 'assets/img/commons/chrome-updater/6Chrome.png' | relative_url }}){: width="350" height="350" .center-image }

Pasando el archivo de strings por <a href="https://github.com/w47son/MalAPIReader" target="_blank">**malapi.py**</a> podemos ver que utiliza API para **enumerar el directorio**.

![Enumerar]({{ 'assets/img/commons/chrome-updater/7Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Vemos que utiliza API para **utilizar Internet**, por lo que enviará o recibirá algo.

![Internet]({{ 'assets/img/commons/chrome-updater/8Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

También utiliza API helper para **crear o abrir un archivo**.

![Archivos]({{ 'assets/img/commons/chrome-updater/9Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Extrayendo las cadenas a través del comando “strings” no dejó más que los imports que hemos visto y que está escrito en golang.

<br/>

Utilizando **floss** podemos extraer los strings ofuscados de una forma más avanzada. Debido a la ofuscación, el proceso tarda un rato.

![Floss]({{ 'assets/img/commons/chrome-updater/10Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Nos devuelve que hay **160.000 strings estáticas** y de las **tight strings** que son descodificadas en la pila, obtenemos que es probable que acceda a los *Bookmarks de Google Chrome* y al archivo *Local State* donde reside la llave de encriptado.

![TightStrings]({{ 'assets/img/commons/chrome-updater/11Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

![Strings]({{ 'assets/img/commons/chrome-updater/12Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

```bash
C:/Users/
/AppData/Local/Google/Chrome/User Data/Default/BookmarksjW
/AppData/Local/Google/Chrome/User Data/Local State
http://10.10.10.6:8080/endpointO[
0123456789abcdef*Af

crypto/cipher: input not full blocks
crypto/aes: invalid key size
```



También parece que accederá a un endpoint llamado endpoint y esa cadena en hexadecimal encriptará los archivos.

### Análisis dinámico

Teniendo en mente que **accede a archivos** y son de **Chrome**, podemos filtrar por **ReadFile**.

Al ejecutar el programa vemos que ha accedido a todos esos archivos de Chrome

![ReadFile]({{ 'assets/img/commons/chrome-updater/13Chrome.png' | relative_url }}){: width="850" height="850" .center-image }

Posterior a ello, vemos que **hubo una conexión** al puerto **8080** de la **10.10.10.6** y **envíos de información notables**.

![Conexion]({{ 'assets/img/commons/chrome-updater/14Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Al analizarlo en **Wireshark** vemos que hubo un **POST** a **/endpoint** de menos de 1 MB y en formato JSON

![Wireshark]({{ 'assets/img/commons/chrome-updater/15Chrome.png' | relative_url }}){: width="850" height="850" .center-image }

Utiliza un **UserAgent genérico** con un authorization custom con el nombre de *W4tson* y un *Issued Time de Sat 15 July 2023 08:30:32 UTC*

![UserAgent]({{ 'assets/img/commons/chrome-updater/16Chrome.png' | relative_url }}){: width="750" height="550" .center-image }

![Cyberchef]({{ 'assets/img/commons/chrome-updater/17Chrome.png' | relative_url }}){: width="750" height="550" .center-image }

Tratando de decodificar la primera clave del JSON, vemos que no funciona.

![Cyberchef]({{ 'assets/img/commons/chrome-updater/18Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Asumimos que se utilizó el **cifrado AES** encontrado en los *strings para cifrar este contenido*, por lo que utilizando el string encontrado **“0123456789abcdef”** podemos descifrar que el texto encriptado era **“w4tsonCookies”** y el **valor clave es el contenido del archivo**. 

![AesDecrypt]({{ 'assets/img/commons/chrome-updater/19Chrome.png' | relative_url }}){: width="350" height="350" .center-image }

<br/>

En **Sysmon** se observa que no hay ningún tipo de información del archivo a la hora de su ejecución.

![Sysmon1]({{ 'assets/img/commons/chrome-updater/20Chrome.png' | relative_url }}){: width="850" height="850" .center-image }

El **ParentImage** de este **cmd.exe / c del** es el mismo chromeUpdater de **eliminándose a sí mismo después de ejecutarse**.

![ParentImage]({{ 'assets/img/commons/chrome-updater/21Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

*El event id 26 registra la eliminación del ejecutable.*

![Captura]({{ 'assets/img/commons/chrome-updater/22Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

Vemos que registró la **IP y el puerto de destino** al que se conectó.

![Captura]({{ 'assets/img/commons/chrome-updater/23Chrome.png' | relative_url }}){: width="550" height="550" .center-image }

**Detección**

**Por defecto**, Windows **no registra el acceso a archivos/carpetas** (objetos), **habilitamos** la **auditoría de objetos** y supervisamos el archivo Local State. 

Después de su ejecución, podemos ver que el proceso **chromeUpdater accedió al archivo**.

![Captura]({{ 'assets/img/commons/chrome-updater/24Chrome.png' | relative_url }}){: width="850" height="850" .center-image }

**Mitigación**

Con todos estos archivos exfiltrados, el **atacante** puede acceder a **todas las contraseñas** del navegador **excepto** si tienes guardadas tus contraseñas en un gestor de contraseñas como **KeePass**.

También podrías utilizar **Firefox** y **guardar tus contraseñas** ahí, ya que te ofrece ponerle una **master password**.